Origami {
  Program
    = Header* Definition* end

  Header
    = "%" line

  Definition
    = Import
    | Function
    | Class


  // ## Imports
  Import
    = import_ String as_ Name ";"                                   -- as
    | import_ String exposing_ NonemptyListOf<Binding, ","> ";"     -- exposing

  Binding
    = Name as_ Name   -- aliased
    | Name            -- original


  // ## Functions
  Function
    = Metadata? function_ FunctionSignature Block

  FunctionSignature
    = FunctionType? Name ParamList

  ParamList
    = "(" ListOf<Name, ","> ")"

  FunctionType
    = "*"     -- generator
    | async_  -- async


  // ## Classes
  Class
    = Metadata? data_ ClassDeclaration      -- data
    | Metadata? ClassDeclaration            -- regular

  ClassDeclaration
    = class_ Name ParamList? SuperClass? "{" Statement* ClassMember* "}"

  SuperClass
    = extends_ Expression 

  ClassMember
    = Metadata? static_ MemberDeclaration    -- static
    | Metadata? member_ MemberDeclaration    -- instance

  MemberDeclaration
    = FunctionType? Name "." Name ParamList Block     -- method
    | Name "." Name "<-" Name Block                   -- setter
    | Name "." Name Block                             -- getter

  String
    = #"\"\"\"" #raw_character* #"\"\"\""       -- raw
    | #"\"" #string_character* #"\""            -- double
  
  Metadata
    = doc_comment

  Block
    = "{" Statement* "}"

  Statement
    = LetStatement
    | AssertStatement
    | Expression ";"    -- expression

  LetStatement
    = let_ mutable_? Name "=" Expression ";"

  AssertStatement
    = assert_ Expression ";"

  Expression
    = IfExpression
    | PipeExpression

  PipeExpression
    = PipeExpression "|>" BinaryExpression  -- pipe
    | YieldAwait

  YieldAwait
    = await_ BinaryExpression       -- await
    | yield_ "*" BinaryExpression   -- yield_all
    | yield_ BinaryExpression       -- yield
    | BinaryExpression

  BinaryExpression
    = UnaryExpression operator UnaryExpression  -- binary
    | UnaryExpression
    
  UnaryExpression
    = PrimaryExpression

  IfExpression
    = if_ Expression then_ Expression else_ Expression

  
  PrimaryExpression
    = Name                  -- variable
    | Literal               -- literal
    | "(" Expression ")"    -- group

  Literal
    = String

  Name
    = ~reserved id

  //-- LEXICAL --------------------------------------------------------
  newline = "\n" | "\r"
  line = (~newline any)*
  comment = "//" line
  doc_comment = "/*" (~"*/" any)* "*/"
  space += comment

  id_start = letter | "_"
  id_rest = id_start | digit
  id = id_start id_rest*

  kw<word> = word ~id_rest

  operator 
    = "===" | "=/=" | "==>"
    | ">="  | ">>"  | ">"
    | "<="  | "<<"  | "<"
    | "++"  | "+"
    | "-"
    | "**"  | "*"
    | "/"
    | and_  | or_


  hex_digit = "0" .. "9" | "a" .. "f" | "A" .. "F" 

  raw_character 
    = ~"\"\"\"" any

  escape_sequence
    = "b"                 -- backspace
    | "f"                 -- form_feed
    | "n"                 -- newline
    | "r"                 -- return
    | "t"                 -- tab
    | "u" unicode_escape  -- unicode

  string_character
    = ~("\"" | "\\") any    -- non_escaped
    | "\\" escape_sequence   -- escaped

  unicode_escape 
    = hex_digit hex_digit hex_digit hex_digit



  import_ = kw<"import">
  exposing_ = kw<"exposing">
  as_ = kw<"as">

  function_ = kw<"function">
  async_ = kw<"async">

  data_ = kw<"data">
  class_ = kw<"class">
  abstract_ = kw<"abstract">
  extends_ = kw<"extends">
  static_ = kw<"static">
  member_ = kw<"member">

  let_ = kw<"let">
  mutable_ = kw<"mutable">

  assert_ = kw<"assert">

  if_ = kw<"if">
  then_ = kw<"then">
  else_ = kw<"else">

  and_ = kw<"and">
  or_ = kw<"or">
  not_ = kw<"not">
  
  await_ = kw<"await">
  yield_ = kw<"yield">

  reserved
    = abstract_ | and_ | assert_ | async_ | as_ | await_
    | class_
    | data_
    | else_ | exposing_ | extends_
    | function_
    | if_ | import_
    | let_
    | member_ | mutable_
    | not_
    | or_
    | static_
    | then_
    | yield_
}